内置类型、自定义类型的机制

# 第二章 变量和基本类型

> **Types** are fundamental to any program: They tell us what our data **mean** and what **operations** we can perform on those data.

## 2.1 原始的内置类型

### 2.1.1 算数类型

算数类型包括整型和浮点型，cpp标准规定了各个类型占用的最小位数

#### signed unsigned

哪些类型区分有无符号？整型除了bool和扩展char类型外，都区分有/无符号

char是signed还是unsigned取决于编译器

选择类型Tips

- 选double：float和double花销忽略不计，float往往精度不够 long double没必要
- 用int：short太短，long又往往和int一样，如果不够用long long

#### 问题

@CSAPP
int short long 区别
double float只是位数不同吗

### 2.1.2 类型转换

#### 赋值时

``` C
unsigned char c1 = -1; // 255
signed char c2 = 256; // 0
// sizeof(1) = 4字节
// 这种赋值时候的做法像是直接截断
```

#### 判断时

if 条件判断自动转换  非bool <=> bool

unsigned类型永远都会大于等于零

#### 计算时

一般来讲是向上转换，尽量不丢失信息
**当一个有符号一个无符号，有符号转为无符号型**

``` C
unsigned u = 10;
int i = -42;
cout << u + i << endl;
// i 先转换为无符号型，之后在相加
```

### 2.1.3 常量

常量的类型都是什么？

常量的类型由前后缀显式决定
注意到：对于浮点数 L是long double 默认double f是float

#### 其他

true false nullptr

## 2.2 变量

A variable provides us with named storage that our programs can manipulate.

### 2.2.1 变量定义

#### 初始化和赋值

初始化是在创建对象时给该对象value，赋值是要覆盖原来的value，在C++中真的有很大的区别吗？

#### list 初始化

@

#### 默认初始化 =》 没有显式初始化

默认值取决于变量的类型和定义的位置

当变量定义在函数外时，会被初始化为0，在函数内时，随机数，正常访问
（书上说是未初始化类型，访问会Error……）

### 2.2.2 变量的声明和定义

为了分离编译，C++区分变量的声明和定义，声明是告诉程序别处有这个变量，定义是让程序弄出个实体来

```C
extern int j; // 声明
int i; // 定义
extern double pi = 3.14; // 定义  覆盖外部的变量 
```

### scope

相同变量名在不同的scope可以有多个定义，内嵌的变量会屏蔽外层的变量，除非有特定的目的，不然不建议这样使用

## 2.3 复合类型

A compound type is a type that is defined in terms of another type.引用和指针就是两种复合类型

### 2.3.1 引用

```C
int refVal = 2;
int &refVal3 = refVal; // reference
int &refVal2 = refVal3; // 2rd alias
```

### 2.3.2 指针

#### 空指针

- **nullptr**
- 0
- NULL #include<cstdlib>

### 指针的引用

```C
int i = 42;
int *p;
int *&r = p;
r = &i;
*r = 0;
```

第三行从右往左读，`&r`代表是一个引用，`int *`代表一个整型指针的引用，所以最后r就是p的引用，就是p的第二个名字，就有了后面两行

### 问题

1. 还有哪些复合类型
2. 引用和指针到底有什么不同
   1. 指针本身是一个object，引用不是
   2. 指针可以被赋值被复制，引用是一次性绑定
   3. 指针不用初始化定义，引用一定要初始化

## 2.4 const 限定符

const 修饰的变量必须定义时初始化，如果不初始化，也行，extern

``` C
extern const int bufSize;
```



### 2.4.1 const类型的引用

#### 定义

```C
const int ci = 1024;
const int &ref = ci;
r1 = 43; // Error
int &r2 = ci; // Error
```

存在绑定引用类型不匹配情况：可以绑定一个**const**引用到一个非const对象，常量 或者表达式

```C
double dval = 3.14;
const int &ri = dval; // pass
// ri => 3
int &ri = dval; // error
```

为什么一定要是const呢？

```C
const int temp = dval;
const int &ri = temp;
```

如果没有const，ri可以修改，那么ri修改的实际是是temp，dval没有变，这显然违背了引用的原意，是不合适的

用const修饰的引用，去引用一个没用const的变量有什么用呢

```C
int i = 43;
int &r1 = i;
const int &r2 = i;
r1 = 0;
r2 = 0; //error
```

该引用对object只读，但是object可以通过别的引用写

### 2.4.2 指针和引用

``` C
const double pi = 3.14;   //pi is const; its value may not be changed
double *ptr = &pi;        //error: ptr is a plain pointer
const double *cptr = &pi; //ok: cptr may point to a double that is const
*cptr = 42;               //error: cannot assign to *cptr
int errNumb = 0;
int *const curErr = &errNumb;  // curErr will always point to errNumb
const double pi = 3.14159;
const double *const pip = &pi; // pip is a const pointer to a const object
```



#### 注意

``` C
const int &r = 0; // pass
int &r = 0; // error
double dval = 3.14;
const int &ri = dval;
// ri => 3
int &ri = dval; //error
```



### 2.4.3 Top-Level const

```Cpp
int i = 0;
int *const p1 = &i;  // we can't change the value of p1; const is top-level

const int ci = 42;   // we cannot change ci; const is top-level
const int *p2 = &ci; // we can change p2; const is low-level

const int *const p3 = p2; // right-most const is top-level, left-most is not
const int &r = ci;  // const in reference types is always low-level
```

`const`关键字限定自己不能改变的就是top-level，否则就是low-level，当复制一个对象的时候，top-level忽略，low-level不能忽略

> low-level 不同，类型不同，如果不能通过convert，就会Error

### 2.4.4 常量表达式

- 初始化定义常量
- 编译时确定

#### constexpr 变量

Variables declared as constexpr are implicitly const and must be initialized by constant
expressions

```Cpp
const int *p = nullptr;     // p is a pointer to a const int p是指向int常量的指针
constexpr int *q = nullptr; // q is a const pointer to int q是指向int的常量指针
```

区别非常大，constexpr在对象上组成了一个top-level const，所以p可以指向另一个const int类型的变量，但是q是top-level，不能改，只能初始化定义死了。

## 2.5 Dealing with Types

### 2.5.1 类型别名

传统方法

``` cpp
typedef double wages; // wages => double
typedef wages base, *p; // base => double  p=>double *
```

新方法

```cpp
// cpp 11
using sufu = wages;
```

### 2.5.2 auto

cpp11 auto ordinarily ignores top-level consts.

``` cpp
int i = 0, &r = i;
const int ci = i, &cr = ci;
auto b = ci;  // b is an int (top-level const in ci is dropped)
auto c = cr;  // c is an int (cr is an alias for ci whose const is top-level)
auto d = &i;  // d is an int*(& of an int object is int*)
auto e = &ci; // e is const int*(& of a const object is low-level const)

const auto f = ci; // deduced type of ci is int; f has type const int

auto k = ci, &l = i;    // k is int; l is int&
auto &m = ci, *p = &ci; // m is a const int&;p is a pointer to const int
// error: type deduced from i is int; type deduced from &ci is const int
auto &n = i, *p2 = &ci;
```



### 2.5.3 decltype

和auto类似，让编辑器猜类型的

```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x has type const int
decltype(cj) y = x; // y has type const int& and is bound to x
decltype(cj) z;     // error: z is a reference and must be initialized
```

## 2.6 写自己的类型

### 2.6.2 写自己的Header文件

Header包含entities

- class定义
- const类型
- constexpr类型



























# 问题

2.15 为什么cpp对`int ival = 1.1`不报错

2.16 自动转换



