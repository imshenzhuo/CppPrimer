# 13 拷贝控制

类规定该类型对象在拷贝、赋值、移动或者销毁时的行为；这些行为通过特殊的成员函数实现

- 拷贝构造函数
- 拷贝赋值函数
- 移动构造函数
- 移动赋值函数
- 析构函数

> 编译器默认的函数可能和我们想象的不大一样

## 13.1 拷贝 赋值 和 销毁

### 13.1.1 拷贝构造函数

什么是拷贝构造函数？

- 构造函数
- 第一个参数是自身类类型的引用
- 任何额外参数都有默认值

#### 合成拷贝构造函数

就是程序员不写，编译器自己生成的拷贝构造函数。

合成拷贝构造函数逐个拷贝类的成员变量，递归调用成员的拷贝构造函数

#### 拷贝初始化

``` cpp
string dots(10, '.');               // direct initialization
string s(dots);                     // direct initialization
string s2 = dots;                   // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, '9');    // copy initialization
```

直接初始化调用最匹配的构造函数

拷贝初始化一般使用拷贝构造函数

拷贝初始化

- 初始化非引用类类型参数
  - 将一个对象作为实参，传给一个非引用的形参
  - 返回一个非引用对象
- 初始化列表
- 容器的insert或者push对象



### 13.1.2 拷贝赋值运算符

什么是拷贝运算符

``` cpp
Sales_data a,b;
b = a;
```

#### 重载运算符

``` cpp
Sales_data &
Salse_data::operator=(const Sales_data &rhs){
    bookNo = rhs.bookNo;
    ...;
    return *this;
}
```



### 13.1.3 析构函数

- 波浪号+类类名
- 没有参数
- 没有返回值

析构函数和构造函数的执行顺序完全相反，先是函数体，再是销毁成员（逆序）

什么时候编写析构函数：删除动态变量的时候

注意：函数体并不直接销毁成员



### 13.1.4 三/五法则

动态变量成员  -> 析构函数 -> 拷贝构造函数/拷贝赋值运算符

拷贝构造函数 <-->拷贝赋值运算符



### 13.1.6 阻止拷贝

#### 定义删除的函数 禁用 C++11

``` cpp
struct NoCoty{
    NoCopy(const NoCopy&) = delete;
}
```

##### delete & default

- delete函数定义就要使用`=delete`
- delete函数是任意函数

#### 析构函数与删除

不能定义该变量和局部变量，但是可以动态分配，分配的对象不能释放！

#### 合成的拷贝控制成员可能是delete的

一个一个类的数据成员不能默认构造、拷贝、复制或销毁，对应的成员函数将被定义为删除的。

#### private 方法





