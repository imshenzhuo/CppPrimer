# 12 动态内存

- 目前为止，全局变量在程序启动时分配，程序结束时销毁；局部变量在进入定义该变量的代码块时创建，离开时销毁；局部static变量在第一次使用时创建，程序结束时销毁。很严格
- C++支持动态内存，动态分配的对象的生存周期和定义的地方无关，程序显式销毁释放
- 动态对象的正确释放很容易出错。C++提供了两个智能指针帮助程序员

> 动态对象存放在堆内存中，其他对象存在栈内存中

## 12.1 动态内存与智能指针

问题

- 忘记释放内存：内存泄露
- 提早释放内存：引用非法内存指针

智能指针自动释放对象，`memory`头文件

- shared_ptr 多个指针指向一个对象
- unique_ptr 一对一

#### 两种指针都有的操作

``` cpp
shared_ptr<T> sp;
unique_ptr<T> up;
p;
*p
p->mem;
p.get(); // 返回p中的指针
swap(p, q);
```



### 12.1.1 shared_ptr

``` cpp
make_shared<T> args
```

最安全的方法是调用标准库中的一个方法`make_shared`

``` cpp
shared_ptr<string> p4 = make_shared<string>(10, '9');
```

#### shared_ptr的拷贝和赋值

每个shared_ptr都会记录有多少个其他shared_ptr指向的对象。shared_ptr的计数器变为0，自动释放内存

``` cpp
auto r = make_shared<int>(42);
r = q;
// q计数器递增；r原来所指的对象自动销毁
```

### 使用动态内存

- 不知道需要多少对象
- 不知道所需对象的准确类型
- 多个对象之间共享数据

C++都是“深”拷贝，所以当想要多个对象共享数据的时候，就要使用动态内存



### 12.1.2 直接管理内存

```cpp
string *ps1 = new string; //默认初始化
string *ps = new string(); // 值初始化
int *pi1 = new int;
int *pi = new int();

auto p1 = new auto(obj);

// 内存耗尽
int *p1 = new int; // new throw std::bad_alloc
int *p2 = new (nothrow) int; // 返回一个空指针
```

释放内存

``` cpp
delete p;
```

#### 释放两次

释放原有的对象后，另一个指针p再次释放，无异于醉汉乱开枪。

### 12.1.3 结合使用

``` cpp
shared_ptr<int> p2(new int(42));
```

注意：二次释放！

``` cpp
auto sp = make_shared<int>();
auto p = sp.get();
delete p;
```

### 12.1.4 智能指针和异常

即使发生了异常，智能指针控制的内存也可以释放，内置指针就不行了

### 12.1.5 unique_ptr

直接初始化，不能复制或者赋值

```cpp
unique_ptr<string> p1(new string("Stagosaurus"));
```

控制转移使用，release并没有赋值

``` cpp
unique_ptr<string> p2(p1.release());
p2.reset(p3.release());
```



## 12.2 动态数组

- new delete
- allocator

能不用就不用

### 12.2.1 new 和 数组

``` cpp
int *pia = new int[变量];
```

#### 注意

- 返回的是元素类型的指针，和数组没有关系，所以维度很关键
- 动态分配一个空数组是合法的
 ``` cpp
char arr[0]; // error
char *cp = new char[0];
 ```

#### 初始化

``` cpp
int *pia = new int[10];
int *pia2 = new int[10]();
int *pia = new int[10]{0,1,2,3,4,5}; // cpp11
```

#### 释放动态数组

``` cpp
delete [] p;
```

#### 智能指针和动态数组

``` cpp
unique_ptr<int []> up(new int[10]);
up.release();
```



### 12.2.2 allocator 类

