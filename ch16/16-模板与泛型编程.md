# 模板与泛型编程

模板是创建类或者函数的蓝本,比如`vector`类型或者`find`函数

与OOP多态不同,蓝本转为特定的类发生在编译时期.

## 16.1 定义模板

起因,函数体完全一样,却要因为类型不同编写重复性的函数体.

### 16.1.1 函数模板

``` cpp
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

#### 实例化**函数**模板

``` cpp
cout << compare(1, 0) << endl;       // T is int
```

当调用一个函数模板的时候, 编译器根据参数推断模板实参(就是上面的`T`)类型, 生成多个模板的实例

所以实际上相当于和编译器说好一个协议,协议就是模板定义的格式,程序员从原来的每个函数都要编写,到现在只需要编写一个模板,重复的工作交给编译器去做.

***

函数模板里面的模板参数有两种

- 类型参数
- 非类型参数

#### 模板类型参数

上面代码中模板的参数就是类型参数,该参数`T`代表一个类型,所以在前面必须要加 `class` 或者 `typename`

#### 模板非类型参数

还有一种模板的参数叫非类型参数, 也就是说模板里面的参数代表的不是类型而是一个值, 比如指定数组大小,但是必须是**常量表达式** 

``` cpp
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}
```

函数调用以及实际上

``` cpp
compare("hi", "mom")
int compare(const char (&p1)[3], const char (&p2)[4])    
```

注意:此处的参数是`const`引用类型,既可以避免大对象的拷贝,也可以保证用于不能拷贝的类型

#### 模板编译

函数模板和类模板成员函数的定义通常放在头文件中.

模板在实例化的时候才会生成对应的代码.

> Q:模板使用不就是实例化吗?
>
> A: 
>
> ``` cpp
> template <typename T> class Stack{ };
> void f1(Stack<char>);
> ```
>
> 

### 16.1.2 类模板

> 生成类的蓝图

与函数模板不同的是,编译器**不能推断**类模板的参数类型,所以就会想`vector<int>`一样,专门写明类型信息

#### 定义类模板

> 以之前`StrBlob`为例,从针对`String`类型泛化到`T`型, 该类的目的在于多个对象共享一块数据

``` cpp
template <typename T> class Blob {
public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;
    // constructors
    Blob();
    Blob(std::initializer_list<T> il);
    // number of elements in the Blob
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // add and remove elements
    void push_back(const T &t) {data->push_back(t);}
    // move version; see § 13.6.3 (p. 548)
    void push_back(T &&t) { data->push_back(std::move(t)); }
    void pop_back();
    // element access
    T& back();
    T& operator[](size_type i); // defined in § 14.5 (p. 566)
private:
    std::shared_ptr<std::vector<T>> data;
    // throws msg if data[i] isn't valid
    void check(size_type i, const std::string &msg) const;
};
```

注意到

- 格式和函数模板类似
- 第四行的重命名要显式 `typename`

#### 实例化模板

必须提供元素类型, 不然编译器没法整

``` cpp
// these definitions instantiate two distinct Blob types
Blob<string> names; // Blob that holds strings
Blob<double> prices;// different element type
```

实例化出两个不同的类, 两者互不相干.

#### 类模板的函数成员

##### 注意

 - `Blob<T>`才是类型名
 - `Blob`是模板名

在类外定义函数和普通成员函数定义有所不同

``` cpp
template <typename T>
ret-type Blob<T>::member-name(parm-list)
```

只有两处变化

- 加上模板声明(不同的类生成不同的函数)
- 作用域变成 `Blob<T>` (区分不同的作用域嘛)

#### 类模板的构造函数

``` cpp
template <typename T> 
Blob<T>::Blob():data(std::make_shared<std::vector<T>>()) {}
```

也没有什么不同的地方

#### 类模板成员函数实例化

首先实例化一个类, 然后该类调用成员函数, 该成员函数才会实例化

#### 不必提供实参

``` cpp
// postfix: increment/decrement the object but return the unchanged value
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    // no check needed here; the call to prefix increment will do the check
    BlobPtr ret = *this;  // save the current value
    ++*this;    // advance one element; prefix ++ checks the increment
    return ret;  // return the saved state
}
```

在类模板的作用域内,可以直接使用模板名而不用指明类名(即指明实参).

#### 类模板和友元

##### 一对一友好

> 类模板与另一个模板建立对应实例的友元

假设对于`Blob<int>`只想要`BlobPtr<int>`做友元关系, 那么

``` cpp
template <typename T> class Blob {
    // ...
    friend class BlobPtr<T>;
    // ...
}
```

只有类型对的上, 才是友元关系

##### 通用和特定的模板友好

``` cpp
// forward declaration necessary to befriend a specific instantiation of a template
template <typename T> class Pal;
class C {  //  C is an ordinary, nontemplate class
    friend class Pal<C>;  // Pal instantiated with class C is a friend to C
    // all instances of Pal2 are friends to C;
    // no forward declaration required when we befriend all instantiations
    template <typename T> friend class Pal2;
};
template <typename T> class C2 { // C2 is itself a class template
    // each instantiation of C2 has the same instance of Pal as a friend
    friend class Pal<T>;  // a template declaration for Pal must be in scope
    // all instances of Pal2 are friends of each instance of C2, prior declaration needed
    template <typename X> friend class Pal2;
    // Pal3 is a nontemplate class that is a friend of every instance of C2
    friend class Pal3;    // prior declaration for Pal3 not needed
};
```

除了一对一还有一对多, 多对多的情况, 总之区分模板名和类名就清楚了.

### 16.1.3 模板参数

#### 模板参数和作用域

模板参数就是那个`T`, 特殊的在于不能重复,只能有一个名字

``` cpp
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
    A tmp = a; // tmp has same type as the template parameter A, not double
    double B;  // error: redeclares template parameter B
}
```

#### 使用类的类型成员

``` cpp
template <typename T>
typename T::value_type top(const T& c)
{
    if (!c.empty())
        return c.back();
    else
        return typename T::value_type();
}
```

这是一个函数模板, 接受`T`的引用, 返回`T`的一个成员

当一个名字表示类型的时候, 要告诉编译器 `typename`

#### 默认模板实参

和函数一样, 模板参数列表也有默认值

``` cpp
template <class T =int> class Foo {
    // ...
};
```



### 16.1.4 成员模板

类(普通/模板)中的成员是个函数模板.

同样, 再怎么也是类模板或者是函数模板, 当在外定义的时候, 先声明类的参数列表, 再声明函数的列表



### 16.1.5 控制实例化

多个文件独立编译模板实例化可能会产生重复的代码, 通过**显式实例化**来避免额外开销

``` cpp
extern template declaration; // instantiation declaration
template declaration;        // instantiation definition
```

declaration是一个类或者函数声明

``` cpp
extern template class vector<string>;
template class vector<Sales_data>;
```

第一行是实例化声明, 表示别的地方实例化了, 此处不用实例化
第二行是实例化定义, 表示就在此处实例化4

### 16.1.6 效率和灵活性





## 16.2 模板实参推断

在调用函数模板的时候,从函数实参来确定模板实参的过程就是模板实参推断.

### 16.2.1 类型转换与模板类型参数

模板实参推断允许发生的类型转换

- 模板参数是const类型引用, 传入非const类型
- 数组和指针

### 16.2.2 函数模板显式实参

不要为难编译器

``` cpp
// T1 cannot be deduced: it doesn't appear in the function parameter list
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);
auto val3 = sum<long long>(i, lng); // long long sum(int, long)
```

显式实参是按照声明顺序来的

特别注意 `long long和long double`之间没有逗号表示一种类型

### 16.2.3 尾置返回类型和类型转换

``` cpp
template <typename It>
auto fcn2(It beg, It end) ->
    typename remove_reference<decltype(*beg)>::type
{
    // process the range
    return *beg;  // return a copy of an element from the range
}
```













## 16.3 重载与模板

## 16.4 可变参数模板

## 16.5 模板特例化

