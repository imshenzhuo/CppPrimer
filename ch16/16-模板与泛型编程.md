# 模板与泛型编程



## 16.1 定义模板

起因

### 16.1.1 函数模板

函数模板 == 公式

#### 实例化函数模板

写好模板,使用时编译器生成多个模板的实例,所以实际上相当于和编译器说好一个协议,协议就是模板定义的格式,程序员从原来的每个函数都有编写,到现在只需要编写一个模板,重复的工作交给编译器去做.

#### 模板类型参数

### 16.1.2 类模板

> 生成类的蓝图

与函数模板不同的是,编译器不能推断类模板的参数类型,所以就会想`vector<int>`一样,专门写明

#### 定义类模板

``` cpp
template <typename T> class Blob {
public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;
    // constructors
    Blob();
    Blob(std::initializer_list<T> il);
    // number of elements in the Blob
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // add and remove elements
    void push_back(const T &t) {data->push_back(t);}
    // move version; see § 13.6.3 (p. 548)
    void push_back(T &&t) { data->push_back(std::move(t)); }
    void pop_back();
    // element access
    T& back();
    T& operator[](size_type i); // defined in § 14.5 (p. 566)
private:
    std::shared_ptr<std::vector<T>> data;
    // throws msg if data[i] isn't valid
    void check(size_type i, const std::string &msg) const;
};
```

#### 实例化模板

``` cpp
// these definitions instantiate two distinct Blob types
Blob<string> names; // Blob that holds strings
Blob<double> prices;// different element type
```

#### 类模板的函数成员

在类外定义函数和普通成员函数定义有所不同

``` cpp
template <typename T>
ret-type Blob<T>::member-name(parm-list)
```

除了要加上模板声明(使用模板参数)和函数名变化,其他完全一致

注意:`Blob<T>`才是类型名

#### 类模板的构造函数

``` cpp
template <typename T> 
Blob<T>::Blob():data(std::make_shared<std::vector<T>>()) {}
```

也没有什么不同的地方

在类的作用域中可以不必指定模板参数T

#### 类模板和友元

##### 一对一友好

- **声明**模板自身
- 在类模板定义中声明友元(特定类型T)

这样,只有指定类型的才有友元关系

##### 通用和特定的模板友好



## 16.2 模板实参推断

## 16.3 重载与模板

## 16.4 可变参数模板

## 16.5 模板特例化

